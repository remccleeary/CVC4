# kinds [for strings theory]
#

theory THEORY_STRINGS ::CVC4::theory::strings::TheoryStrings "theory/strings/theory_strings.h"

properties stable-infinite check

rewriter ::CVC4::theory::strings::TheoryStringsRewriter "theory/strings/theory_strings_rewriter.h"

#typechecker "theory/strings/theory_strings_type_rules.h"
typechecker "theory/builtin/theory_builtin_type_rules.h"

#   variable K ["comment"]
#
#     This declares a kind K that has no operator (it's conceptually a
#     VARIABLE).  This is appropriate for things like VARIABLE and
#     SKOLEM.
#
#   operator K #children ["comment"]
#
#     Declares a "built-in" operator kind K.  Really this is the same
#     as "variable" except that it has an operator (automatically
#     generated by NodeManager).
#
#     You can specify an exact # of children required as the second
#     argument to the operator command.  In debug mode, assertions are
#     automatically included to ensure that no Nodes can ever be
#     created violating this.  (FIXME: the public Expr stuff should
#     enforce them regardless of whether debugging or not.)  For
#     example, a binary operator could be specified as:
#
#         operator LESS_THAN 2 "arithmetic comparison, x < y"
#
#     Alternatively, a range can be specified for #children as
#     "LB:[UB]", LB and UB representing lower and upper bounds on the
#     number of children (inclusive).  If there is no lower bound, put
#     a "1" (operators must have at least one child).  If there is no
#     upper bound, leave the colon after LB, but omit UB.  For example,
#     an N-ary operator might be defined as:
#
#         operator PLUS 2: "addition on two or more arguments"
#
#   parameterized K #children ["comment"]
#
#     Declares a "built-in" parameterized operator kind K.  This is a
#     theory-specific APPLY, e.g., APPLY_UF, which applies its first
#     parameter (say, "f"), to its operands (say, "x" and "y", making
#     the full application "f(x,y)").  Nodes with such a kind will
#     have an operator (Node::hasOperator() returns true, and
#     Node::getOperator() returns the Node of functional type
#     representing "f" here), and the "children" are defined to be
#     this operator's parameters, and don't include the operator
#     itself (here, there are only two children "x" and "y").
#
#     LB and UB are the same as documented for the operator command,
#     except that parameterized operators may have zero children.  The
#     first parameter (the function being applied) does not count as a
#     child.
#
#     For consistency these should start with "APPLY_", but this is
#     not enforced.
#
#   constant K T Hasher header ["comment"]
#
#     Declares a constant kind K.  T is the C++ type representing the
#     constant internally (and it should be
#     ::fully::qualified::like::this), and header is the header needed
#     to define it.  Hasher is a hash functor type defined like this:
#
#       struct MyHashFcn {
#         size_t operator()(const T& val) const;
#       };
#
#     For consistency, constants taking a non-void payload should
#     start with "CONST_", but this is not enforced.
#
#   typerule K typechecker-class
#
#     Declares that a (previously-declared) kind K is typechecked by
#     the typechecker-class.  This class should be defined by the
#     header given to the "typechecker" command, above.  The
#     typechecker-class is used this way by the main TypeChecker code:
#
#       typechecker-class::computeType(NodeManager* nm, TNode n, bool check)
#
#     It returns TypeNode.  It should compute the type of n and return it,
#     and if "check" is true, should actually perform type checking instead
#     of simply type computation.
#
#   sort K cardinality [well-founded ground-term header | not-well-founded] ["comment"]
#
#     This creates a kind K that represents a sort (a "type constant").
#     These kinds of types are "atomic" types; if you need to describe
#     a complex type that takes type arguments (like arrays), use
#     "operator"; if you need to describe one that takes "constant"
#     arguments (like bitvectors), use "constant", and if you invent
#     one that takes both, you could try "parameterized".  In those
#     cases, you'll want to provide a cardinality separately for your
#     type.
#
#     The cardinality argument is a nonnegative number (if the sort is
#     finite), or Cardinality::INTEGERS if the sort has the same
#     cardinality as the integers, or Cardinality::REALS if the sort
#     has the same cardinality as the reals.
#
#     If the sort is well-founded (i.e., there exist ground terms),
#     then the argument should be the string "well-founded"; if not,
#     it should be the string "not-well-founded".  If well-founded,
#     two extra arguments immediately follow---a C++ expression that
#     constructs a ground term (as a Node), and the header that must
#     be #included for that expression to compile.
#
#     For consistency, sorts should end with "_TYPE", but this is not
#     enforced.
#
#   cardinality K cardinality-computer [header]
#
#     This command does not define a kind; the kind K needs to be
#     defined by one of the other commands above.  This command just
#     provides a cardinality for types of kind K.  The
#     "cardinality-computer" is a C++ expression that will yield a
#     Cardinality for the type.  In that expression, the sequence of
#     characters "%TYPE%" will be rewritten with a variable containing
#     a TypeNode of kind K.  The optional "header" argument is an
#     include file necessary to compile the cardinality-computer
#     expression.
#
#     If the cardinality need not be computed per-type (i.e., it's the
#     same for all types of kind K, but the "sort" gesture above could
#     not be used---in which case it doesn't already have a registered
#     cardinality), you can simply construct a Cardinality temporary.
#     For example:
#
#       cardinality MY_TYPE Cardinality(Cardinality::INTEGERS)
#
#     If not, you might opt to use a computer; a common place to put it
#     is with your type checker:
#
#       cardinality MY_TYPE \
#           ::CVC4::theory::foo::TheoryFoo::CardinalityComputer(%TYPE%) \
#           "theory/foo/theory_foo_type_rules.h"
#
#   well-founded K wellfoundedness-computer ground-term-computer [header]
#
#     Analogous to the "cardinality" command above, the well-founded
#     command provides a well-foundedness computer for the type.  A
#     ground term computer is required unless the
#     wellfoundedness-computer is the constant "false".  The ground
#     term computer should return a Node, and it should return the
#     same Node each time for a given type (although usually it's only
#     ever called once anyway since the result is cached).
#
#
# Lines may be broken with a backslash between arguments; for example:
#
#     constant CONST_INT \
#         int IntHash \
#         "" \
#         "This is a constant representing an INT.
#         Its payload is the C++ int type.
#         It is used by the theory of arithmetic."
#
# As shown in the example, ["comment"] fields may be broken across
# multiple lines too.
#
# The expr package guarantees that Nodes built with kinds have the
# following constraints imposed on them.  (The #children guarantee
# only holds when assertions are turned on.)
#
#   Node meta-kind      has operator?      # children
#   ==================  =================  =======================
#   variable            no                 zero
#   operator            yes                as documented above
#   parameterized       yes                as documented above
#   constant            no                 zero
#
# NOTE THAT This file is actually an executable Bourne shell script
# (sourced by the processing scripts after defining functions called
# "theory," "variable," "operator," "parameterized," and "constant").
# Please don't do anything else in this file other than using these
# commands.

endtheory
